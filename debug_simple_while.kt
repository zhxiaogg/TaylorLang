import kotlinx.collections.immutable.persistentListOf
import org.taylorlang.ast.*
import org.taylorlang.codegen.BytecodeGenerator
import org.taylorlang.typechecker.RefactoredTypeChecker
import java.io.File
import java.util.concurrent.TimeUnit

fun main() {
    val generator = BytecodeGenerator()
    val typeChecker = RefactoredTypeChecker()
    val tempDir = File("debug_temp")
    tempDir.mkdirs()

    // Create program: while (false) { println("loop") }; println("done")
    val whileLoop = WhileExpression(
        condition = Literal.BooleanLiteral(false),
        body = FunctionCall(
            target = Identifier("println"),
            arguments = persistentListOf(Literal.StringLiteral("loop"))
        )
    )
    val statements = persistentListOf(
        whileLoop,
        FunctionCall(
            target = Identifier("println"),
            arguments = persistentListOf(Literal.StringLiteral("done"))
        )
    )
    val program = Program(statements)

    // Type check the program
    val typedResult = typeChecker.typeCheck(program)
    typedResult.onSuccess { typedProgram ->
        
        // Generate bytecode
        val codegenResult = generator.generateBytecode(typedProgram, tempDir, "SimpleWhileDebug")
        codegenResult.onSuccess { generationResult ->
            
            val classFile = generationResult.bytecodeFiles.first()
            println("Generated class file: ${classFile.absolutePath}")
            
            // Execute the generated bytecode
            val command = listOf("java", "-cp", tempDir.absolutePath, "SimpleWhileDebug")
            val processBuilder = ProcessBuilder(command)
            processBuilder.directory(tempDir)
            
            val process = processBuilder.start()
            val success = process.waitFor(5, TimeUnit.SECONDS)
            
            val output = process.inputStream.bufferedReader().readText().trim()
            val errorOutput = process.errorStream.bufferedReader().readText().trim()
            val exitCode = if (success) process.exitValue() else -1
            
            println("Exit code: $exitCode")
            println("Output: '$output'")
            if (errorOutput.isNotEmpty()) {
                println("Error: '$errorOutput'")
            }
        }.onFailure { e ->
            println("Codegen failed: ${e.message}")
            e.printStackTrace()
        }
    }.onFailure { e ->
        println("Type check failed: ${e.message}")
        e.printStackTrace()
    }

    // Clean up
    tempDir.deleteRecursively()
}