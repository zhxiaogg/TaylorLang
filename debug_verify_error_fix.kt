import org.taylorlang.parser.TaylorLangParser
import org.taylorlang.typechecker.RefactoredTypeChecker
import org.taylorlang.codegen.BytecodeGenerator
import java.io.File
import java.nio.file.Files

fun main() {
    val parser = TaylorLangParser()
    val typeChecker = RefactoredTypeChecker()
    val generator = BytecodeGenerator()
    
    // Simple test case that previously caused VerifyError
    val sourceCode = "println(42)"
    
    println("Testing simple println with integer...")
    
    val parseResult = parser.parse(sourceCode)
    if (parseResult.isFailure) {
        println("Parse error: ${parseResult.exceptionOrNull()?.message}")
        return
    }
    
    val program = parseResult.getOrNull()!!
    
    val typedResult = typeChecker.typeCheck(program)
    if (typedResult.isFailure) {
        println("Type checking error: ${typedResult.exceptionOrNull()?.message}")
        return
    }
    
    val typedProgram = typedResult.getOrNull()!!
    
    val tempDir = Files.createTempDirectory("verify_test").toFile()
    val codegenResult = generator.generateBytecode(typedProgram, tempDir, "TestVerifyFix")
    
    if (codegenResult.isFailure) {
        println("Codegen error: ${codegenResult.exceptionOrNull()?.message}")
        return
    }
    
    val generationResult = codegenResult.getOrNull()!!
    val classFile = generationResult.bytecodeFiles.first()
    
    println("Generated bytecode: ${classFile.absolutePath}")
    
    // Try to execute the generated class
    try {
        val command = listOf("java", "-cp", tempDir.absolutePath, "TestVerifyFix")
        val process = ProcessBuilder(command)
            .directory(tempDir)
            .start()
        
        val success = process.waitFor()
        val output = process.inputStream.bufferedReader().readText()
        val errorOutput = process.errorStream.bufferedReader().readText()
        
        println("Exit code: $success")
        println("Output: $output")
        if (errorOutput.isNotEmpty()) {
            println("Error output: $errorOutput")
        }
        
        if (success == 0) {
            println("SUCCESS: VerifyError is fixed!")
        } else {
            println("FAILED: Still has execution issues")
        }
    } catch (e: Exception) {
        println("Execution failed: ${e.message}")
    } finally {
        tempDir.deleteRecursively()
    }
}