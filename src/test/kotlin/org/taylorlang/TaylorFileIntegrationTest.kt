package org.taylorlang

import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.result.shouldBeSuccess
import io.kotest.matchers.shouldBe
import org.taylorlang.codegen.BytecodeGenerator
import org.taylorlang.parser.TaylorLangParser
import org.taylorlang.typechecker.RefactoredTypeChecker
import java.io.File
import java.nio.file.Files
import java.util.concurrent.TimeUnit

/**
 * Integration test that loads all Taylor language files from src/test/resources/test_cases
 * and compiles/executes them to verify there are no errors.
 */
class TaylorFileIntegrationTest : DescribeSpec({
    
    val parser = TaylorLangParser()
    val typeChecker = RefactoredTypeChecker()
    val generator = BytecodeGenerator()
    val tempDir = Files.createTempDirectory("taylor_file_test").toFile()
    
    afterSpec {
        // Clean up temp directory
        tempDir.deleteRecursively()
    }
    
    describe("Taylor file compilation and execution") {
        
        val testCasesDir = File("src/test/resources/test_cases")
        
        if (testCasesDir.exists() && testCasesDir.isDirectory) {
            val taylorFiles = testCasesDir.listFiles { _, name -> 
                name.endsWith(".taylor") 
            } ?: emptyArray()
            
            if (taylorFiles.isEmpty()) {
                it("should find Taylor files in test_cases directory") {
                    throw AssertionError("No .taylor files found in ${testCasesDir.absolutePath}")
                }
            } else {
                taylorFiles.forEach { file ->
                    it("should compile and run ${file.name} without errors") {
                        // Read the Taylor source code
                        val sourceCode = file.readText()
                        
                        // Parse the source code
                        val parseResult = parser.parse(sourceCode)
                        parseResult shouldBeSuccess { program ->
                            
                            // Type check the program
                            val typedResult = typeChecker.typeCheck(program)
                            typedResult shouldBeSuccess { typedProgram ->
                                
                                // Generate a safe class name from the file name
                                val className = file.nameWithoutExtension
                                    .replace(Regex("[^a-zA-Z0-9]"), "")
                                    .replaceFirstChar { it.uppercase() } + "Test"
                                
                                // Generate bytecode
                                val codegenResult = generator.generateBytecode(
                                    typedProgram, 
                                    tempDir, 
                                    className
                                )
                                codegenResult shouldBeSuccess { generationResult ->
                                    
                                    val classFile = generationResult.bytecodeFiles.first()
                                    classFile.exists() shouldBe true
                                    
                                    // Execute the generated bytecode
                                    val executionResult = executeJavaClass(tempDir, className)

                                    // Print the actual output from running the Taylor program
                                    println("=== Output from ${file.name} ===")
                                    println(executionResult.output)
                                    if (executionResult.errorOutput.isNotEmpty()) {
                                        println("=== Error Output ===")
                                        println(executionResult.errorOutput)
                                    }
                                    println("=== End of Output ===\n")
                                    executionResult.exitCode shouldBe 0
                                }
                            }
                        }
                    }
                }
            }
        } else {
            it("should have test_cases directory") {
                throw AssertionError("Test cases directory not found: ${testCasesDir.absolutePath}")
            }
        }
    }
}) {
    companion object {
        
        data class ExecutionResult(
            val exitCode: Int,
            val output: String,
            val errorOutput: String
        )
        
        /**
         * Execute a compiled Java class using the java command
         */
        private fun executeJavaClass(
            classDir: File,
            className: String,
            args: List<String> = emptyList()
        ): ExecutionResult {
            // CRITICAL FIX: Include both the generated class directory AND the runtime classes
            // The generated Taylor classes reference TaylorResult runtime classes, so we need
            // both directories in the classpath for execution to work
            val runtimeClassesDir = File("build/classes/kotlin/main").absolutePath
            
            // CRITICAL FIX: Also include Kotlin standard library to handle Kotlin-specific classes
            // like kotlin.NoWhenBranchMatchedException used in pattern matching bytecode
            // Use the entire current classpath which includes all Kotlin libraries
            val currentClasspath = System.getProperty("java.class.path")
            
            val classpath = "${classDir.absolutePath}${File.pathSeparator}${runtimeClassesDir}${File.pathSeparator}${currentClasspath}"
            val command = listOf("java", "-cp", classpath, className) + args
            
            val processBuilder = ProcessBuilder(command)
            processBuilder.directory(classDir)
            
            val process = processBuilder.start()
            val success = process.waitFor(10, TimeUnit.SECONDS)
            
            val output = process.inputStream.bufferedReader().readText().trim()
            val errorOutput = process.errorStream.bufferedReader().readText().trim()
            val exitCode = if (success) process.exitValue() else -1
            
            return ExecutionResult(exitCode, output, errorOutput)
        }
    }
}