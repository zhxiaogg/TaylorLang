package org.taylorlang.codegen

import io.kotest.core.spec.style.StringSpec
import io.kotest.matchers.shouldBe
import org.taylorlang.parser.TaylorLangParser
import org.taylorlang.typechecker.TypedProgram
import org.taylorlang.typechecker.StatementTypeChecker
import org.taylorlang.typechecker.TypeContext

class VariableWhileLoopIntegrationTest : StringSpec({
    val parser = TaylorLangParser()
    val context = TypeContext.withBuiltins()
    val generator = BytecodeGenerator()
    
    "should generate bytecode for while loop with variable counter" {
        val code = """
            var counter: Int = 0
            while (counter < 5) {
                println(counter);
                counter = counter + 1;
            }
            println("Done")
        """.trimIndent()
        
        // Parse the program
        val program = parser.parse(code).getOrThrow()
        
        // Type check statements sequentially
        val statementChecker = StatementTypeChecker(context)
        val typedStatements = program.statements.map { statement ->
            statement.accept(statementChecker).getOrThrow()
        }
        
        val typedProgram = TypedProgram(typedStatements)
        
        // Generate bytecode (should not throw)
        val result = generator.generateBytecode(typedProgram)
        result.isSuccess shouldBe true
        
        // Verify that we generated bytecode files
        val generationResult = result.getOrThrow()
        generationResult.bytecodeFiles.isNotEmpty() shouldBe true
    }
    
    "should generate bytecode for nested variable usage" {
        val code = """
            var x: Int = 10
            var y: Int = 20
            var sum: Int = 0
            while (x > 0) {
                sum = sum + y;
                x = x - 1;
            }
            println(sum)
        """.trimIndent()
        
        // Parse the program
        val program = parser.parse(code).getOrThrow()
        
        // Type check statements sequentially
        val statementChecker = StatementTypeChecker(context)
        val typedStatements = program.statements.map { statement ->
            statement.accept(statementChecker).getOrThrow()
        }
        
        val typedProgram = TypedProgram(typedStatements)
        
        // Generate bytecode (should not throw)
        val result = generator.generateBytecode(typedProgram)
        result.isSuccess shouldBe true
    }
    
    "should generate bytecode for variable reassignment with complex expressions" {
        val code = """
            var a: Int = 5
            var b: Int = 10
            var result: Int = 0
            while (a < b) {
                result = a * b + result;
                a = a + 2;
            }
            println(result)
        """.trimIndent()
        
        // Parse the program
        val program = parser.parse(code).getOrThrow()
        
        // Type check statements sequentially
        val statementChecker = StatementTypeChecker(context)
        val typedStatements = program.statements.map { statement ->
            statement.accept(statementChecker).getOrThrow()
        }
        
        val typedProgram = TypedProgram(typedStatements)
        
        // Generate bytecode (should not throw)
        val result = generator.generateBytecode(typedProgram)
        result.isSuccess shouldBe true
    }
})