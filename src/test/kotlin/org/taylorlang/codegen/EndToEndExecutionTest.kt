package org.taylorlang.codegen

import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.result.shouldBeSuccess
import io.kotest.matchers.shouldBe
import io.kotest.matchers.shouldNotBe
import kotlinx.collections.immutable.persistentListOf
import org.taylorlang.ast.*
import org.taylorlang.parser.TaylorLangParser
import org.taylorlang.typechecker.*
import java.io.File
import java.nio.file.Files
import java.nio.file.Paths
import java.util.concurrent.TimeUnit

/**
 * End-to-end tests that compile TaylorLang programs to bytecode
 * and execute them with the JVM to verify functionality.
 */
class EndToEndExecutionTest : DescribeSpec({
    
    val generator = BytecodeGenerator()
    val typeChecker = RefactoredTypeChecker()
    val tempDir = Files.createTempDirectory("taylor_execution_test").toFile()
    
    afterSpec {
        // Clean up temp directory
        tempDir.deleteRecursively()
    }
    
    describe("Simple expression execution") {
        
        it("should execute program with integer arithmetic") {
            // Create TaylorLang program: println(5 + 3 * 2)
            val innerExpr = BinaryOp(
                Literal.IntLiteral(3),
                BinaryOperator.MULTIPLY,
                Literal.IntLiteral(2)
            )
            val outerExpr = BinaryOp(
                Literal.IntLiteral(5),
                BinaryOperator.PLUS,
                innerExpr
            )
            val printCall = FunctionCall(
                target = Identifier("println"),
                arguments = persistentListOf(outerExpr)
            )
            val program = Program(persistentListOf(printCall))
            
            // Type check the program
            val typedResult = typeChecker.typeCheck(program)
            typedResult shouldBeSuccess { typedProgram ->
                
                // Generate bytecode
                val codegenResult = generator.generateBytecode(typedProgram, tempDir, "ArithmeticTest")
                codegenResult shouldBeSuccess { generationResult ->
                    
                    val classFile = generationResult.bytecodeFiles.first()
                    classFile.exists() shouldBe true
                    
                    // Execute the generated bytecode
                    val result = executeJavaClass(tempDir, "ArithmeticTest")
                    result.exitCode shouldBe 0
                }
            }
        }
        
        it("should execute program with string literals") {
            // Create TaylorLang program: println("Hello, Bytecode World!")
            val printCall = FunctionCall(
                target = Identifier("println"),
                arguments = persistentListOf(Literal.StringLiteral("Hello, Bytecode World!"))
            )
            val program = Program(persistentListOf(printCall))
            
            // Type check the program
            val typedResult = typeChecker.typeCheck(program)
            typedResult shouldBeSuccess { typedProgram ->
                
                // Generate bytecode
                val codegenResult = generator.generateBytecode(typedProgram, tempDir, "StringTest")
                codegenResult shouldBeSuccess { generationResult ->
                    
                    val classFile = generationResult.bytecodeFiles.first()
                    classFile.exists() shouldBe true
                    
                    // Execute the generated bytecode
                    val result = executeJavaClass(tempDir, "StringTest")
                    result.exitCode shouldBe 0
                    result.output shouldBe "Hello, Bytecode World!"
                }
            }
        }
        
        it("should execute program with double arithmetic") {
            // Create TaylorLang program: println(5.5 + 2.5)
            val expr = BinaryOp(
                Literal.FloatLiteral(5.5),
                BinaryOperator.PLUS,
                Literal.FloatLiteral(2.5)
            )
            val printCall = FunctionCall(
                target = Identifier("println"),
                arguments = persistentListOf(expr)
            )
            val program = Program(persistentListOf(printCall))
            
            // Type check the program
            val typedResult = typeChecker.typeCheck(program)
            typedResult shouldBeSuccess { typedProgram ->
                
                // Generate bytecode
                val codegenResult = generator.generateBytecode(typedProgram, tempDir, "DoubleTest")
                codegenResult shouldBeSuccess { generationResult ->
                    
                    val classFile = generationResult.bytecodeFiles.first()
                    classFile.exists() shouldBe true
                    
                    // Execute the generated bytecode
                    val result = executeJavaClass(tempDir, "DoubleTest")
                    result.exitCode shouldBe 0
                    result.output shouldBe "8.0"
                }
            }
        }
        
        it("should execute program with boolean operations") {
            // Create TaylorLang program: println(!true)
            val expr = UnaryOp(UnaryOperator.NOT, Literal.BooleanLiteral(true))
            val printCall = FunctionCall(
                target = Identifier("println"),
                arguments = persistentListOf(expr)
            )
            val program = Program(persistentListOf(printCall))
            
            // Type check the program
            val typedResult = typeChecker.typeCheck(program)
            typedResult shouldBeSuccess { typedProgram ->
                
                // Generate bytecode
                val codegenResult = generator.generateBytecode(typedProgram, tempDir, "BooleanTest")
                codegenResult shouldBeSuccess { generationResult ->
                    
                    val classFile = generationResult.bytecodeFiles.first()
                    classFile.exists() shouldBe true
                    
                    // Execute the generated bytecode
                    val result = executeJavaClass(tempDir, "BooleanTest")
                    result.exitCode shouldBe 0
                    result.output shouldBe "false" // false as "false"
                }
            }
        }
        
        it("should execute program with comparison operations") {
            // Create TaylorLang program: println(5 > 3)
            val expr = BinaryOp(
                Literal.IntLiteral(5),
                BinaryOperator.GREATER_THAN,
                Literal.IntLiteral(3)
            )
            val printCall = FunctionCall(
                target = Identifier("println"),
                arguments = persistentListOf(expr)
            )
            val program = Program(persistentListOf(printCall))
            
            // Type check the program
            val typedResult = typeChecker.typeCheck(program)
            typedResult shouldBeSuccess { typedProgram ->
                
                // Generate bytecode
                val codegenResult = generator.generateBytecode(typedProgram, tempDir, "ComparisonTest")
                codegenResult shouldBeSuccess { generationResult ->
                    
                    val classFile = generationResult.bytecodeFiles.first()
                    classFile.exists() shouldBe true
                    
                    // Execute the generated bytecode
                    val result = executeJavaClass(tempDir, "ComparisonTest")
                    result.exitCode shouldBe 0
                    result.output shouldBe "true"
                }
            }
        }
        
        it("should execute program with equality comparison") {
            // Create TaylorLang program: println(42 == 42)
            val expr = BinaryOp(
                Literal.IntLiteral(42),
                BinaryOperator.EQUAL,
                Literal.IntLiteral(42)
            )
            val printCall = FunctionCall(
                target = Identifier("println"),
                arguments = persistentListOf(expr)
            )
            val program = Program(persistentListOf(printCall))
            
            // Type check the program
            val typedResult = typeChecker.typeCheck(program)
            typedResult shouldBeSuccess { typedProgram ->
                
                // Generate bytecode
                val codegenResult = generator.generateBytecode(typedProgram, tempDir, "EqualityTest")
                codegenResult shouldBeSuccess { generationResult ->
                    
                    val classFile = generationResult.bytecodeFiles.first()
                    classFile.exists() shouldBe true
                    
                    // Execute the generated bytecode
                    val result = executeJavaClass(tempDir, "EqualityTest")
                    result.exitCode shouldBe 0
                    result.output shouldBe "true"
                }
            }
        }
        
        it("should execute program with double comparison") {
            // Create TaylorLang program: println(3.5 < 4.0)
            val expr = BinaryOp(
                Literal.FloatLiteral(3.5),
                BinaryOperator.LESS_THAN,
                Literal.FloatLiteral(4.0)
            )
            val printCall = FunctionCall(
                target = Identifier("println"),
                arguments = persistentListOf(expr)
            )
            val program = Program(persistentListOf(printCall))
            
            // Type check the program
            val typedResult = typeChecker.typeCheck(program)
            typedResult shouldBeSuccess { typedProgram ->
                
                // Generate bytecode
                val codegenResult = generator.generateBytecode(typedProgram, tempDir, "DoubleComparisonTest")
                codegenResult shouldBeSuccess { generationResult ->
                    
                    val classFile = generationResult.bytecodeFiles.first()
                    classFile.exists() shouldBe true
                    
                    // Execute the generated bytecode
                    val result = executeJavaClass(tempDir, "DoubleComparisonTest")
                    result.exitCode shouldBe 0
                    result.output shouldBe "true"
                }
            }
        }
        
        it("should execute program with mixed type comparison") {
            // Create TaylorLang program: println(5 == 5.0) - tests type coercion
            val expr = BinaryOp(
                Literal.IntLiteral(5),
                BinaryOperator.EQUAL,
                Literal.FloatLiteral(5.0)
            )
            val printCall = FunctionCall(
                target = Identifier("println"),
                arguments = persistentListOf(expr)
            )
            val program = Program(persistentListOf(printCall))
            
            // Type check the program
            val typedResult = typeChecker.typeCheck(program)
            typedResult shouldBeSuccess { typedProgram ->
                
                // Generate bytecode
                val codegenResult = generator.generateBytecode(typedProgram, tempDir, "MixedComparisonTest")
                codegenResult shouldBeSuccess { generationResult ->
                    
                    val classFile = generationResult.bytecodeFiles.first()
                    classFile.exists() shouldBe true
                    
                    // Execute the generated bytecode
                    val result = executeJavaClass(tempDir, "MixedComparisonTest")
                    result.exitCode shouldBe 0
                    result.output shouldBe "true"
                }
            }
        }
    }
    
    describe("Control flow execution") {
        
        it("should execute program with simple if expression") {
            // Create TaylorLang program: println(if (true) "yes" else "no")
            val ifExpr = IfExpression(
                condition = Literal.BooleanLiteral(true),
                thenExpression = Literal.StringLiteral("yes"),
                elseExpression = Literal.StringLiteral("no")
            )
            val printCall = FunctionCall(
                target = Identifier("println"),
                arguments = persistentListOf(ifExpr)
            )
            val program = Program(persistentListOf(printCall))
            
            // Type check the program
            val typedResult = typeChecker.typeCheck(program)
            typedResult shouldBeSuccess { typedProgram ->
                
                // Generate bytecode
                val codegenResult = generator.generateBytecode(typedProgram, tempDir, "SimpleIfTest")
                codegenResult shouldBeSuccess { generationResult ->
                    
                    val classFile = generationResult.bytecodeFiles.first()
                    classFile.exists() shouldBe true
                    
                    // Execute the generated bytecode
                    val result = executeJavaClass(tempDir, "SimpleIfTest")
                    result.exitCode shouldBe 0
                    result.output shouldBe "yes"
                }
            }
        }
        
        it("should execute program with if-else based on comparison") {
            // Create TaylorLang program: println(if (5 > 3) 1 else 0)
            val condition = BinaryOp(
                Literal.IntLiteral(5),
                BinaryOperator.GREATER_THAN,
                Literal.IntLiteral(3)
            )
            val ifExpr = IfExpression(
                condition = condition,
                thenExpression = Literal.IntLiteral(1),
                elseExpression = Literal.IntLiteral(0)
            )
            val printCall = FunctionCall(
                target = Identifier("println"),
                arguments = persistentListOf(ifExpr)
            )
            val program = Program(persistentListOf(printCall))
            
            // Type check the program
            val typedResult = typeChecker.typeCheck(program)
            typedResult shouldBeSuccess { typedProgram ->
                
                // Generate bytecode
                val codegenResult = generator.generateBytecode(typedProgram, tempDir, "IfComparisonTest")
                codegenResult shouldBeSuccess { generationResult ->
                    
                    val classFile = generationResult.bytecodeFiles.first()
                    classFile.exists() shouldBe true
                    
                    // Execute the generated bytecode
                    val result = executeJavaClass(tempDir, "IfComparisonTest")
                    result.exitCode shouldBe 0
                    result.output shouldBe "1"
                }
            }
        }
        
        it("should execute program with nested if expression") {
            // Create TaylorLang program: println(if (true) if (false) "a" else "b" else "c")
            val innerIf = IfExpression(
                condition = Literal.BooleanLiteral(false),
                thenExpression = Literal.StringLiteral("a"),
                elseExpression = Literal.StringLiteral("b")
            )
            val outerIf = IfExpression(
                condition = Literal.BooleanLiteral(true),
                thenExpression = innerIf,
                elseExpression = Literal.StringLiteral("c")
            )
            val printCall = FunctionCall(
                target = Identifier("println"),
                arguments = persistentListOf(outerIf)
            )
            val program = Program(persistentListOf(printCall))
            
            // Type check the program
            val typedResult = typeChecker.typeCheck(program)
            typedResult shouldBeSuccess { typedProgram ->
                
                // Generate bytecode
                val codegenResult = generator.generateBytecode(typedProgram, tempDir, "NestedIfTest")
                codegenResult shouldBeSuccess { generationResult ->
                    
                    val classFile = generationResult.bytecodeFiles.first()
                    classFile.exists() shouldBe true
                    
                    // Execute the generated bytecode
                    val result = executeJavaClass(tempDir, "NestedIfTest")
                    result.exitCode shouldBe 0
                    result.output shouldBe "b"
                }
            }
        }
        
        it("should execute program with if expression without else") {
            // Create TaylorLang program: println(if (false) 42 else 0) - simulating if without else
            val ifExpr = IfExpression(
                condition = Literal.BooleanLiteral(false),
                thenExpression = Literal.IntLiteral(42),
                elseExpression = null // This should generate default value
            )
            val printCall = FunctionCall(
                target = Identifier("println"),
                arguments = persistentListOf(ifExpr)
            )
            val program = Program(persistentListOf(printCall))
            
            // Type check the program
            val typedResult = typeChecker.typeCheck(program)
            typedResult shouldBeSuccess { typedProgram ->
                
                // Generate bytecode
                val codegenResult = generator.generateBytecode(typedProgram, tempDir, "IfWithoutElseTest")
                codegenResult shouldBeSuccess { generationResult ->
                    
                    val classFile = generationResult.bytecodeFiles.first()
                    classFile.exists() shouldBe true
                    
                    // Execute the generated bytecode
                    val result = executeJavaClass(tempDir, "IfWithoutElseTest")
                    result.exitCode shouldBe 0
                    result.output shouldBe "0" // Should print default value for int (0)
                }
            }
        }
        
        it("should execute program with boolean AND operation") {
            // Create TaylorLang program: println(true && false)
            val expr = BinaryOp(
                Literal.BooleanLiteral(true),
                BinaryOperator.AND,
                Literal.BooleanLiteral(false)
            )
            val printCall = FunctionCall(
                target = Identifier("println"),
                arguments = persistentListOf(expr)
            )
            val program = Program(persistentListOf(printCall))
            
            // Type check the program
            val typedResult = typeChecker.typeCheck(program)
            typedResult shouldBeSuccess { typedProgram ->
                
                // Generate bytecode
                val codegenResult = generator.generateBytecode(typedProgram, tempDir, "BooleanAndTest")
                codegenResult shouldBeSuccess { generationResult ->
                    
                    val classFile = generationResult.bytecodeFiles.first()
                    classFile.exists() shouldBe true
                    
                    // Execute the generated bytecode
                    val result = executeJavaClass(tempDir, "BooleanAndTest")
                    result.exitCode shouldBe 0
                    result.output shouldBe "false"
                }
            }
        }
        
        it("should execute program with boolean OR operation") {
            // Create TaylorLang program: println(false || true)
            val expr = BinaryOp(
                Literal.BooleanLiteral(false),
                BinaryOperator.OR,
                Literal.BooleanLiteral(true)
            )
            val printCall = FunctionCall(
                target = Identifier("println"),
                arguments = persistentListOf(expr)
            )
            val program = Program(persistentListOf(printCall))
            
            // Type check the program
            val typedResult = typeChecker.typeCheck(program)
            typedResult shouldBeSuccess { typedProgram ->
                
                // Generate bytecode
                val codegenResult = generator.generateBytecode(typedProgram, tempDir, "BooleanOrTest")
                codegenResult shouldBeSuccess { generationResult ->
                    
                    val classFile = generationResult.bytecodeFiles.first()
                    classFile.exists() shouldBe true
                    
                    // Execute the generated bytecode
                    val result = executeJavaClass(tempDir, "BooleanOrTest")
                    result.exitCode shouldBe 0
                    result.output shouldBe "true"
                }
            }
        }
        
        it("should execute program with complex boolean expression") {
            // Create TaylorLang program: println((true && false) || (5 > 3))
            val leftSide = BinaryOp(
                Literal.BooleanLiteral(true),
                BinaryOperator.AND,
                Literal.BooleanLiteral(false)
            )
            val rightSide = BinaryOp(
                Literal.IntLiteral(5),
                BinaryOperator.GREATER_THAN,
                Literal.IntLiteral(3)
            )
            val expr = BinaryOp(
                leftSide,
                BinaryOperator.OR,
                rightSide
            )
            val printCall = FunctionCall(
                target = Identifier("println"),
                arguments = persistentListOf(expr)
            )
            val program = Program(persistentListOf(printCall))
            
            // Type check the program
            val typedResult = typeChecker.typeCheck(program)
            typedResult shouldBeSuccess { typedProgram ->
                
                // Generate bytecode
                val codegenResult = generator.generateBytecode(typedProgram, tempDir, "ComplexBooleanTest")
                codegenResult shouldBeSuccess { generationResult ->
                    
                    val classFile = generationResult.bytecodeFiles.first()
                    classFile.exists() shouldBe true
                    
                    // Execute the generated bytecode
                    val result = executeJavaClass(tempDir, "ComplexBooleanTest")
                    result.exitCode shouldBe 0
                    result.output shouldBe "true"
                }
            }
        }
        
        it("should execute program with simple while loop") {
            // Create TaylorLang program: while (false) { println("loop") }; println("done")
            val whileLoop = WhileExpression(
                condition = Literal.BooleanLiteral(false),
                body = FunctionCall(
                    target = Identifier("println"),
                    arguments = persistentListOf(Literal.StringLiteral("loop"))
                )
            )
            val statements = persistentListOf(
                whileLoop,
                FunctionCall(
                    target = Identifier("println"),
                    arguments = persistentListOf(Literal.StringLiteral("done"))
                )
            )
            val program = Program(statements)
            
            // Type check the program
            val typedResult = typeChecker.typeCheck(program)
            typedResult shouldBeSuccess { typedProgram ->
                
                // Generate bytecode
                val codegenResult = generator.generateBytecode(typedProgram, tempDir, "WhileLoopTest")
                codegenResult shouldBeSuccess { generationResult ->
                    
                    val classFile = generationResult.bytecodeFiles.first()
                    classFile.exists() shouldBe true
                    
                    // Execute the generated bytecode
                    val result = executeJavaClass(tempDir, "WhileLoopTest")
                    result.exitCode shouldBe 0
                    result.output shouldBe "done" // Should only print "done" since loop never executes
                }
            }
        }
        
        it("should execute program with while loop using comparison") {
            // Create TaylorLang program: while (1 > 2) { println("never") }; println("after")
            val condition = BinaryOp(
                Literal.IntLiteral(1),
                BinaryOperator.GREATER_THAN,
                Literal.IntLiteral(2)
            )
            val whileLoop = WhileExpression(
                condition = condition,
                body = FunctionCall(
                    target = Identifier("println"),
                    arguments = persistentListOf(Literal.StringLiteral("never"))
                )
            )
            val statements = persistentListOf(
                whileLoop,
                FunctionCall(
                    target = Identifier("println"),
                    arguments = persistentListOf(Literal.StringLiteral("after"))
                )
            )
            val program = Program(statements)
            
            // Type check the program
            val typedResult = typeChecker.typeCheck(program)
            typedResult shouldBeSuccess { typedProgram ->
                
                // Generate bytecode
                val codegenResult = generator.generateBytecode(typedProgram, tempDir, "WhileComparisonTest")
                codegenResult shouldBeSuccess { generationResult ->
                    
                    val classFile = generationResult.bytecodeFiles.first()
                    classFile.exists() shouldBe true
                    
                    // Execute the generated bytecode
                    val result = executeJavaClass(tempDir, "WhileComparisonTest")
                    result.exitCode shouldBe 0
                    result.output shouldBe "after" // Condition is false, so loop doesn't execute
                }
            }
        }
    }
    
    describe("Multiple statements execution") {
        
        it("should execute program with multiple println statements") {
            val statements = persistentListOf(
                FunctionCall(
                    target = Identifier("println"),
                    arguments = persistentListOf(Literal.StringLiteral("First line"))
                ),
                FunctionCall(
                    target = Identifier("println"),
                    arguments = persistentListOf(Literal.StringLiteral("Second line"))
                ),
                FunctionCall(
                    target = Identifier("println"),
                    arguments = persistentListOf(Literal.IntLiteral(42))
                )
            )
            val program = Program(statements)
            
            // Type check the program
            val typedResult = typeChecker.typeCheck(program)
            typedResult shouldBeSuccess { typedProgram ->
                
                // Generate bytecode
                val codegenResult = generator.generateBytecode(typedProgram, tempDir, "MultiStatementTest")
                codegenResult shouldBeSuccess { generationResult ->
                    
                    val classFile = generationResult.bytecodeFiles.first()
                    classFile.exists() shouldBe true
                    
                    // Execute the generated bytecode
                    val result = executeJavaClass(tempDir, "MultiStatementTest")
                    result.exitCode shouldBe 0
                    result.output shouldBe "First line\nSecond line\n42"
                }
            }
        }
    }
    
    describe("Function declaration execution") {
        
        it("should execute program with main function") {
            // Create main function that prints a message
            val printCall = FunctionCall(
                target = Identifier("println"),
                arguments = persistentListOf(Literal.StringLiteral("Main function executed"))
            )
            val mainFunc = FunctionDecl(
                name = "main",
                parameters = persistentListOf(),
                returnType = BuiltinTypes.UNIT,
                body = FunctionBody.ExpressionBody(printCall)
            )
            val program = Program(persistentListOf(mainFunc))
            
            // Type check the program
            val typedResult = typeChecker.typeCheck(program)
            typedResult shouldBeSuccess { typedProgram ->
                
                // Generate bytecode
                val codegenResult = generator.generateBytecode(typedProgram, tempDir, "MainFunctionTest")
                codegenResult shouldBeSuccess { generationResult ->
                    
                    val classFile = generationResult.bytecodeFiles.first()
                    classFile.exists() shouldBe true
                    
                    // Execute the generated bytecode
                    val result = executeJavaClass(tempDir, "MainFunctionTest")
                    result.exitCode shouldBe 0
                    result.output shouldBe "Main function executed"
                }
            }
        }
    }
    
    describe("Bytecode verifier compliance") {
        
        it("should generate bytecode that passes JVM verification") {
            // Create a simple program
            val printCall = FunctionCall(
                target = Identifier("println"),
                arguments = persistentListOf(Literal.StringLiteral("Verification test"))
            )
            val program = Program(persistentListOf(printCall))
            
            // Type check and generate bytecode
            val typedResult = typeChecker.typeCheck(program)
            typedResult shouldBeSuccess { typedProgram ->
                
                val codegenResult = generator.generateBytecode(typedProgram, tempDir, "VerificationTest")
                codegenResult shouldBeSuccess { generationResult ->
                    
                    val classFile = generationResult.bytecodeFiles.first()
                    classFile.exists() shouldBe true
                    
                    // Verify the bytecode loads without verification errors
                    val verifyResult = verifyJavaClass(tempDir, "VerificationTest")
                    verifyResult.exitCode shouldBe 0
                    
                    // And that it executes successfully
                    val execResult = executeJavaClass(tempDir, "VerificationTest")
                    execResult.exitCode shouldBe 0
                }
            }
        }
    }
}) {
    companion object {
        
        data class ExecutionResult(
            val exitCode: Int,
            val output: String,
            val errorOutput: String
        )
        
        /**
         * Execute a compiled Java class using the java command
         */
        private fun executeJavaClass(
            classDir: File,
            className: String,
            args: List<String> = emptyList()
        ): ExecutionResult {
            val command = listOf("java", "-cp", classDir.absolutePath, className) + args
            
            val processBuilder = ProcessBuilder(command)
            processBuilder.directory(classDir)
            
            val process = processBuilder.start()
            val success = process.waitFor(10, TimeUnit.SECONDS)
            
            val output = process.inputStream.bufferedReader().readText().trim()
            val errorOutput = process.errorStream.bufferedReader().readText().trim()
            val exitCode = if (success) process.exitValue() else -1
            
            return ExecutionResult(exitCode, output, errorOutput)
        }
        
        /**
         * Verify a compiled Java class using java -verify
         */
        private fun verifyJavaClass(
            classDir: File,
            className: String
        ): ExecutionResult {
            val command = listOf("java", "-verify", "-cp", classDir.absolutePath, className, "--dry-run")
            
            val processBuilder = ProcessBuilder(command)
            processBuilder.directory(classDir)
            
            val process = processBuilder.start()
            val success = process.waitFor(10, TimeUnit.SECONDS)
            
            val output = process.inputStream.bufferedReader().readText().trim()
            val errorOutput = process.errorStream.bufferedReader().readText().trim()
            val exitCode = if (success) process.exitValue() else -1
            
            return ExecutionResult(exitCode, output, errorOutput)
        }
    }
}