package org.taylorlang.codegen

import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.result.shouldBeSuccess
import io.kotest.matchers.shouldBe
import io.kotest.matchers.shouldNotBe
import kotlinx.collections.immutable.persistentListOf
import org.taylorlang.ast.*
import org.taylorlang.parser.TaylorLangParser
import org.taylorlang.typechecker.*
import java.io.File
import java.nio.file.Files
import java.nio.file.Paths
import java.util.concurrent.TimeUnit

/**
 * End-to-end tests that compile TaylorLang programs to bytecode
 * and execute them with the JVM to verify functionality.
 */
class EndToEndExecutionTest : DescribeSpec({
    
    val generator = BytecodeGenerator()
    val typeChecker = RefactoredTypeChecker()
    val tempDir = Files.createTempDirectory("taylor_execution_test").toFile()
    
    afterSpec {
        // Clean up temp directory
        tempDir.deleteRecursively()
    }
    
    describe("Simple expression execution") {
        
        it("should execute program with integer arithmetic") {
            // Create TaylorLang program: println(5 + 3 * 2)
            val innerExpr = BinaryOp(
                Literal.IntLiteral(3),
                BinaryOperator.MULTIPLY,
                Literal.IntLiteral(2)
            )
            val outerExpr = BinaryOp(
                Literal.IntLiteral(5),
                BinaryOperator.PLUS,
                innerExpr
            )
            val printCall = FunctionCall(
                target = Identifier("println"),
                arguments = persistentListOf(outerExpr)
            )
            val program = Program(persistentListOf(printCall))
            
            // Type check the program
            val typedResult = typeChecker.typeCheck(program)
            typedResult shouldBeSuccess { typedProgram ->
                
                // Generate bytecode
                val codegenResult = generator.generateBytecode(typedProgram, tempDir, "ArithmeticTest")
                codegenResult shouldBeSuccess { generationResult ->
                    
                    val classFile = generationResult.bytecodeFiles.first()
                    classFile.exists() shouldBe true
                    
                    // Execute the generated bytecode
                    val result = executeJavaClass(tempDir, "ArithmeticTest")
                    result.exitCode shouldBe 0
                }
            }
        }
        
        it("should execute program with string literals") {
            // Create TaylorLang program: println("Hello, Bytecode World!")
            val printCall = FunctionCall(
                target = Identifier("println"),
                arguments = persistentListOf(Literal.StringLiteral("Hello, Bytecode World!"))
            )
            val program = Program(persistentListOf(printCall))
            
            // Type check the program
            val typedResult = typeChecker.typeCheck(program)
            typedResult shouldBeSuccess { typedProgram ->
                
                // Generate bytecode
                val codegenResult = generator.generateBytecode(typedProgram, tempDir, "StringTest")
                codegenResult shouldBeSuccess { generationResult ->
                    
                    val classFile = generationResult.bytecodeFiles.first()
                    classFile.exists() shouldBe true
                    
                    // Execute the generated bytecode
                    val result = executeJavaClass(tempDir, "StringTest")
                    result.exitCode shouldBe 0
                    result.output shouldBe "Hello, Bytecode World!"
                }
            }
        }
        
        it("should execute program with double arithmetic") {
            // Create TaylorLang program: println(5.5 + 2.5)
            val expr = BinaryOp(
                Literal.FloatLiteral(5.5),
                BinaryOperator.PLUS,
                Literal.FloatLiteral(2.5)
            )
            val printCall = FunctionCall(
                target = Identifier("println"),
                arguments = persistentListOf(expr)
            )
            val program = Program(persistentListOf(printCall))
            
            // Type check the program
            val typedResult = typeChecker.typeCheck(program)
            typedResult shouldBeSuccess { typedProgram ->
                
                // Generate bytecode
                val codegenResult = generator.generateBytecode(typedProgram, tempDir, "DoubleTest")
                codegenResult shouldBeSuccess { generationResult ->
                    
                    val classFile = generationResult.bytecodeFiles.first()
                    classFile.exists() shouldBe true
                    
                    // Execute the generated bytecode
                    val result = executeJavaClass(tempDir, "DoubleTest")
                    result.exitCode shouldBe 0
                    result.output shouldBe "8.0"
                }
            }
        }
        
        it("should execute program with boolean operations") {
            // Create TaylorLang program: println(!true)
            val expr = UnaryOp(UnaryOperator.NOT, Literal.BooleanLiteral(true))
            val printCall = FunctionCall(
                target = Identifier("println"),
                arguments = persistentListOf(expr)
            )
            val program = Program(persistentListOf(printCall))
            
            // Type check the program
            val typedResult = typeChecker.typeCheck(program)
            typedResult shouldBeSuccess { typedProgram ->
                
                // Generate bytecode
                val codegenResult = generator.generateBytecode(typedProgram, tempDir, "BooleanTest")
                codegenResult shouldBeSuccess { generationResult ->
                    
                    val classFile = generationResult.bytecodeFiles.first()
                    classFile.exists() shouldBe true
                    
                    // Execute the generated bytecode
                    val result = executeJavaClass(tempDir, "BooleanTest")
                    result.exitCode shouldBe 0
                    result.output shouldBe "false" // false as "false"
                }
            }
        }
    }
    
    describe("Multiple statements execution") {
        
        it("should execute program with multiple println statements") {
            val statements = persistentListOf(
                FunctionCall(
                    target = Identifier("println"),
                    arguments = persistentListOf(Literal.StringLiteral("First line"))
                ),
                FunctionCall(
                    target = Identifier("println"),
                    arguments = persistentListOf(Literal.StringLiteral("Second line"))
                ),
                FunctionCall(
                    target = Identifier("println"),
                    arguments = persistentListOf(Literal.IntLiteral(42))
                )
            )
            val program = Program(statements)
            
            // Type check the program
            val typedResult = typeChecker.typeCheck(program)
            typedResult shouldBeSuccess { typedProgram ->
                
                // Generate bytecode
                val codegenResult = generator.generateBytecode(typedProgram, tempDir, "MultiStatementTest")
                codegenResult shouldBeSuccess { generationResult ->
                    
                    val classFile = generationResult.bytecodeFiles.first()
                    classFile.exists() shouldBe true
                    
                    // Execute the generated bytecode
                    val result = executeJavaClass(tempDir, "MultiStatementTest")
                    result.exitCode shouldBe 0
                    result.output shouldBe "First line\nSecond line\n42"
                }
            }
        }
    }
    
    describe("Function declaration execution") {
        
        it("should execute program with main function") {
            // Create main function that prints a message
            val printCall = FunctionCall(
                target = Identifier("println"),
                arguments = persistentListOf(Literal.StringLiteral("Main function executed"))
            )
            val mainFunc = FunctionDecl(
                name = "main",
                parameters = persistentListOf(),
                returnType = BuiltinTypes.UNIT,
                body = FunctionBody.ExpressionBody(printCall)
            )
            val program = Program(persistentListOf(mainFunc))
            
            // Type check the program
            val typedResult = typeChecker.typeCheck(program)
            typedResult shouldBeSuccess { typedProgram ->
                
                // Generate bytecode
                val codegenResult = generator.generateBytecode(typedProgram, tempDir, "MainFunctionTest")
                codegenResult shouldBeSuccess { generationResult ->
                    
                    val classFile = generationResult.bytecodeFiles.first()
                    classFile.exists() shouldBe true
                    
                    // Execute the generated bytecode
                    val result = executeJavaClass(tempDir, "MainFunctionTest")
                    result.exitCode shouldBe 0
                    result.output shouldBe "Main function executed"
                }
            }
        }
    }
    
    describe("Bytecode verifier compliance") {
        
        it("should generate bytecode that passes JVM verification") {
            // Create a simple program
            val printCall = FunctionCall(
                target = Identifier("println"),
                arguments = persistentListOf(Literal.StringLiteral("Verification test"))
            )
            val program = Program(persistentListOf(printCall))
            
            // Type check and generate bytecode
            val typedResult = typeChecker.typeCheck(program)
            typedResult shouldBeSuccess { typedProgram ->
                
                val codegenResult = generator.generateBytecode(typedProgram, tempDir, "VerificationTest")
                codegenResult shouldBeSuccess { generationResult ->
                    
                    val classFile = generationResult.bytecodeFiles.first()
                    classFile.exists() shouldBe true
                    
                    // Verify the bytecode loads without verification errors
                    val verifyResult = verifyJavaClass(tempDir, "VerificationTest")
                    verifyResult.exitCode shouldBe 0
                    
                    // And that it executes successfully
                    val execResult = executeJavaClass(tempDir, "VerificationTest")
                    execResult.exitCode shouldBe 0
                }
            }
        }
    }
}) {
    companion object {
        
        data class ExecutionResult(
            val exitCode: Int,
            val output: String,
            val errorOutput: String
        )
        
        /**
         * Execute a compiled Java class using the java command
         */
        private fun executeJavaClass(
            classDir: File,
            className: String,
            args: List<String> = emptyList()
        ): ExecutionResult {
            val command = listOf("java", "-cp", classDir.absolutePath, className) + args
            
            val processBuilder = ProcessBuilder(command)
            processBuilder.directory(classDir)
            
            val process = processBuilder.start()
            val success = process.waitFor(10, TimeUnit.SECONDS)
            
            val output = process.inputStream.bufferedReader().readText().trim()
            val errorOutput = process.errorStream.bufferedReader().readText().trim()
            val exitCode = if (success) process.exitValue() else -1
            
            return ExecutionResult(exitCode, output, errorOutput)
        }
        
        /**
         * Verify a compiled Java class using java -verify
         */
        private fun verifyJavaClass(
            classDir: File,
            className: String
        ): ExecutionResult {
            val command = listOf("java", "-verify", "-cp", classDir.absolutePath, className, "--dry-run")
            
            val processBuilder = ProcessBuilder(command)
            processBuilder.directory(classDir)
            
            val process = processBuilder.start()
            val success = process.waitFor(10, TimeUnit.SECONDS)
            
            val output = process.inputStream.bufferedReader().readText().trim()
            val errorOutput = process.errorStream.bufferedReader().readText().trim()
            val exitCode = if (success) process.exitValue() else -1
            
            return ExecutionResult(exitCode, output, errorOutput)
        }
    }
}