package org.taylorlang.codegen

import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.result.shouldBeSuccess
import io.kotest.matchers.shouldBe
import org.taylorlang.ast.*
import org.taylorlang.typechecker.*
import kotlinx.collections.immutable.persistentListOf
import java.io.File
import java.nio.file.Files
import java.util.concurrent.TimeUnit

/**
 * Simple integration test to demonstrate that generated bytecode 
 * can actually be executed by the JVM.
 */
class SimpleBytecodeExecutionTest : DescribeSpec({
    
    val generator = BytecodeGenerator()
    val tempDir = Files.createTempDirectory("taylor_simple_test").toFile()
    
    afterSpec {
        // Clean up temp directory
        tempDir.deleteRecursively()
    }
    
    describe("Simple bytecode execution demonstration") {
        
        it("should generate and execute bytecode for arithmetic expression") {
            // Create a simple arithmetic expression: 5 + 3
            val expr = BinaryOp(
                Literal.IntLiteral(5),
                BinaryOperator.PLUS,
                Literal.IntLiteral(3)
            )
            
            val typedExpr = TypedExpression(expr, BuiltinTypes.INT)
            val stmt = TypedStatement.ExpressionStatement(typedExpr)
            val program = TypedProgram(listOf(stmt))
            
            // Generate bytecode
            val result = generator.generateBytecode(program, tempDir, "SimpleArithmetic")
            
            result shouldBeSuccess { generationResult ->
                val classFile = generationResult.bytecodeFiles.first()
                classFile.exists() shouldBe true
                
                // Test that the class file can be loaded by the JVM
                // This validates that our bytecode is valid
                val javaResult = runJavaCommand(tempDir, "SimpleArithmetic")
                javaResult.exitCode shouldBe 0 // Should not crash
            }
        }
        
        it("should generate and execute bytecode for function with return value") {
            // Create function: fn getValue() => 42
            val returnExpr = Literal.IntLiteral(42)
            val body = TypedFunctionBody.Expression(TypedExpression(returnExpr, BuiltinTypes.INT))
            
            val funcDecl = FunctionDecl(
                name = "getValue",
                parameters = persistentListOf(),
                returnType = BuiltinTypes.INT,
                body = FunctionBody.ExpressionBody(returnExpr)
            )
            
            val typedFunc = TypedStatement.FunctionDeclaration(funcDecl, body)
            val program = TypedProgram(listOf(typedFunc))
            
            // Generate bytecode
            val result = generator.generateBytecode(program, tempDir, "FunctionTest")
            
            result shouldBeSuccess { generationResult ->
                val classFile = generationResult.bytecodeFiles.first()
                classFile.exists() shouldBe true
                
                // Test that the class file is valid JVM bytecode
                val javaResult = runJavaCommand(tempDir, "FunctionTest")
                javaResult.exitCode shouldBe 0 // Should not crash
            }
        }
        
        it("should generate valid bytecode for complex nested expressions") {
            // Create: (5 + 3) * (10 - 2)
            val left = BinaryOp(
                Literal.IntLiteral(5),
                BinaryOperator.PLUS,
                Literal.IntLiteral(3)
            )
            val right = BinaryOp(
                Literal.IntLiteral(10),
                BinaryOperator.MINUS,
                Literal.IntLiteral(2)
            )
            val expr = BinaryOp(left, BinaryOperator.MULTIPLY, right)
            
            val typedExpr = TypedExpression(expr, BuiltinTypes.INT)
            val stmt = TypedStatement.ExpressionStatement(typedExpr)
            val program = TypedProgram(listOf(stmt))
            
            // Generate bytecode
            val result = generator.generateBytecode(program, tempDir, "ComplexExpression")
            
            result shouldBeSuccess { generationResult ->
                val classFile = generationResult.bytecodeFiles.first()
                classFile.exists() shouldBe true
                
                // Verify the bytecode is valid
                val javaResult = runJavaCommand(tempDir, "ComplexExpression")
                javaResult.exitCode shouldBe 0 // Should not crash
            }
        }
        
        it("should validate bytecode with JVM verifier") {
            // Create a simple program to verify bytecode correctness
            val expr = Literal.IntLiteral(123)
            val typedExpr = TypedExpression(expr, BuiltinTypes.INT)
            val stmt = TypedStatement.ExpressionStatement(typedExpr)
            val program = TypedProgram(listOf(stmt))
            
            // Generate bytecode
            val result = generator.generateBytecode(program, tempDir, "VerifierTest")
            
            result shouldBeSuccess { generationResult ->
                val classFile = generationResult.bytecodeFiles.first()
                classFile.exists() shouldBe true
                
                // Run with verification enabled - this should not fail
                val javaResult = runJavaCommand(tempDir, "VerifierTest", listOf("-verify"))
                javaResult.exitCode shouldBe 0 // Bytecode should pass JVM verification
            }
        }
    }
}) {
    companion object {
        
        data class ExecutionResult(
            val exitCode: Int,
            val output: String,
            val errorOutput: String
        )
        
        /**
         * Run a Java class to test that our bytecode is executable
         */
        private fun runJavaCommand(
            classDir: File,
            className: String,
            jvmArgs: List<String> = emptyList()
        ): ExecutionResult {
            val command = listOf("java") + jvmArgs + listOf("-cp", classDir.absolutePath, className)
            
            val processBuilder = ProcessBuilder(command)
            processBuilder.directory(classDir)
            
            return try {
                val process = processBuilder.start()
                val success = process.waitFor(5, TimeUnit.SECONDS)
                
                val output = process.inputStream.bufferedReader().readText().trim()
                val errorOutput = process.errorStream.bufferedReader().readText().trim()
                val exitCode = if (success) process.exitValue() else -1
                
                ExecutionResult(exitCode, output, errorOutput)
            } catch (e: Exception) {
                ExecutionResult(-1, "", "Exception: ${e.message}")
            }
        }
    }
}