// Constructor patterns test - Real Taylor constructor pattern syntax
// Testing actual constructor patterns with union types

// Real union type definitions
type Result<T, E> = Ok(T) | Error(E)

// Pattern 1: Result type with constructor patterns  
val result = Ok(42)
val processedResult = match result {
    case Ok(value) => "Success: " + value
    case Error(err) => "Error: " + err
}
assert(processedResult == "Success: 42")

// Pattern 2: Option type with constructor patterns
type Option<T> = Some(T) | None

val option = Some("Hello")
val processedOption = match option {
    case Some(value) => "Value: " + value
    case None() => "No value"
}
assert(processedOption == "Value: Hello")

// Pattern 3: Simple union type without recursion
type Status = Active | Inactive | Pending  

val status = Active()
val processedStatus = match status {
    case Active() => "System is active"
    case Inactive() => "System is inactive" 
    case Pending() => "System is pending"
}
assert(processedStatus == "System is active")

// Pattern 4: Constructor patterns demonstrating real syntax  
// (Simplified to avoid complex nested patterns until bytecode is implemented)
val simpleResult = Error("not found")
val errorMessage = match simpleResult {
    case Ok(data) => "Got: " + data
    case Error(msg) => "Error: " + msg
}
assert(errorMessage == "Error: not found")

// Pattern 5: Tuple constructor patterns (Phase 1 approach from design)
type Tuple2<A, B> = Pair(A, B)

val tuple = Pair(10, 20)  
val tupleSum = match tuple {
    case Pair(x, y) => x + y
}
assert(tupleSum == 30)

println("Constructor pattern tests completed!")