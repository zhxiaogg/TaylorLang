// Lambda Expressions Test Case - Real Lambda Syntax
// Tests lambda expression creation and type checking

// Lambda creation tests
println("Testing lambda expression creation...")

// Single parameter lambda: x => x * 2
val doubleFunction = x => x * 2
println("Created doubling lambda: x => x * 2")

// Single parameter lambda: x => x * x
val squareFunction = x => x * x
println("Created squaring lambda: x => x * x")

// Single parameter lambda with conditional: x => if (x > 0) x else -x
val absFunction = x => if (x > 0) x else -x
println("Created absolute value lambda: x => if (x > 0) x else -x")

// Two parameter lambda: (x, y) => x + y
val addFunction = (x, y) => x + y
println("Created addition lambda: (x, y) => x + y")

// Boolean logic lambda: x => x >= 18
val eligibilityFunction = x => x >= 18
println("Created eligibility lambda: x => x >= 18")

// Closure with captured variable
val multiplier = 3
val multiplyByThree = x => x * multiplier
println("Created closure lambda: x => x * multiplier")

// Identity lambda
val identity = x => x
println("Created identity lambda: x => x")

// Constant lambda
val constantFive = x => 5
println("Created constant lambda: x => 5")

// NOTE: Lambda function calling is not yet implemented in the bytecode generator
// The following functionality will be available once bytecode generation is complete:
//
// val result1 = doubleFunction(5)  // Should return 10
// val result2 = squareFunction(4)  // Should return 16
// val result3 = addFunction(15, 25)  // Should return 40
// 
// NOTE: String operations in lambda parameters currently have type inference issues
// This will be fixed in a separate update:
// val exclamationFunction = s => s + "!"  // Currently causes type unification error
// 
// For now, we verify that lambda expressions can be created and type-checked successfully

println("All lambda expressions created successfully!")
println("Lambda type checking completed!")