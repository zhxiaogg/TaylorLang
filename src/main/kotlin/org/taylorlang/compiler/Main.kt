package org.taylorlang.compiler

import org.taylorlang.parser.TaylorLangParser
import org.taylorlang.typechecker.TypeChecker
import org.taylorlang.codegen.BytecodeGenerator
import java.io.File
import kotlin.system.exitProcess

/**
 * Main entry point for the TaylorLang compiler
 */
fun main(args: Array<String>) {
    if (args.isEmpty()) {
        println("Usage: taylorlang <source-file>")
        exitProcess(1)
    }
    
    val sourceFile = File(args[0])
    if (!sourceFile.exists()) {
        println("Error: File '${args[0]}' not found")
        exitProcess(1)
    }
    
    try {
        val source = sourceFile.readText()
        compile(source, sourceFile.name)
    } catch (e: Exception) {
        println("Error reading file: ${e.message}")
        exitProcess(1)
    }
}

/**
 * Compile TaylorLang source code through the complete pipeline
 */
fun compile(source: String, fileName: String) {
    val parser = TaylorLangParser()
    val typeChecker = TypeChecker()
    val codeGenerator = BytecodeGenerator()
    
    // Phase 1: Parsing
    println("Phase 1: Parsing...")
    val program = parser.parse(source, fileName).fold(
        onSuccess = { program ->
            println("✓ Successfully parsed $fileName")
            println("  Program contains ${program.statements.size} statements")
            program.statements.forEachIndexed { index, statement ->
                println("  Statement ${index + 1}: ${statement::class.simpleName}")
            }
            program
        },
        onFailure = { error ->
            println("Parse error: ${error.message}")
            exitProcess(1)
        }
    )
    
    // Phase 2: Type Checking
    println("\nPhase 2: Type Checking...")
    val typedProgram = typeChecker.typeCheck(program).fold(
        onSuccess = { typedProgram ->
            println("✓ Type checking completed successfully")
            println("  Typed ${typedProgram.statements.size} statements")
            typedProgram
        },
        onFailure = { error ->
            println("Type checking error: ${error.message}")
            exitProcess(1)
        }
    )
    
    // Phase 3: Code Generation
    println("\nPhase 3: Code Generation...")
    codeGenerator.generateBytecode(typedProgram).fold(
        onSuccess = { result ->
            println("✓ Bytecode generation completed")
            println("  Generated ${result.bytecodeFiles.size} class files")
            result.mainClassName?.let { mainClass ->
                println("  Main class: $mainClass")
            }
        },
        onFailure = { error ->
            println("Code generation not yet implemented:")
            println("  ${error.message}")
            println("\nThe compiler successfully completed parsing and type checking.")
            println("Run with generated bytecode will be available in future versions.")
        }
    )
    
    println("\nCompilation Summary:")
    println("  ✓ Parsing: Success")
    println("  ✓ Type Checking: Success") 
    println("  ⚠ Code Generation: Not implemented yet")
}