import kotlinx.collections.immutable.persistentListOf
import org.taylorlang.ast.*
import org.taylorlang.codegen.BytecodeGenerator
import org.taylorlang.typechecker.RefactoredTypeChecker
import java.io.File
import java.nio.file.Files

fun main() {
    println("Testing main function exit code behavior...")
    
    val generator = BytecodeGenerator()
    val typeChecker = RefactoredTypeChecker()
    val tempDir = Files.createTempDirectory("exit_code_test").toFile()
    
    try {
        // Create main function that prints a message
        val printCall = FunctionCall(
            target = Identifier("println"),
            arguments = persistentListOf(Literal.StringLiteral("Main function executed"))
        )
        val mainFunc = FunctionDecl(
            name = "main",
            parameters = persistentListOf(),
            returnType = BuiltinTypes.UNIT,
            body = FunctionBody.ExpressionBody(printCall)
        )
        val program = Program(persistentListOf(mainFunc))
        
        // Type check the program
        val typedResult = typeChecker.typeCheck(program)
        
        if (typedResult.isSuccess) {
            val typedProgram = typedResult.getOrThrow()
            
            // Generate bytecode
            val codegenResult = generator.generateBytecode(typedProgram, tempDir, "TestMainExit")
            
            if (codegenResult.isSuccess) {
                val generationResult = codegenResult.getOrThrow()
                val classFile = generationResult.bytecodeFiles.first()
                
                if (classFile.exists()) {
                    println("Bytecode generated successfully: ${classFile.absolutePath}")
                    
                    // Execute the generated bytecode
                    val command = listOf("java", "-cp", tempDir.absolutePath, "TestMainExit")
                    val processBuilder = ProcessBuilder(command)
                    processBuilder.directory(tempDir)
                    
                    val process = processBuilder.start()
                    val success = process.waitFor(10, java.util.concurrent.TimeUnit.SECONDS)
                    
                    val output = process.inputStream.bufferedReader().readText().trim()
                    val errorOutput = process.errorStream.bufferedReader().readText().trim()
                    val exitCode = if (success) process.exitValue() else -1
                    
                    println("Output: $output")
                    println("Error: $errorOutput")
                    println("Exit code: $exitCode")
                    
                    if (exitCode != 0) {
                        println("ERROR: Expected exit code 0, got $exitCode")
                    } else {
                        println("SUCCESS: Exit code is 0 as expected")
                    }
                } else {
                    println("ERROR: Class file was not created")
                }
            } else {
                println("ERROR: Bytecode generation failed: ${codegenResult.exceptionOrNull()}")
            }
        } else {
            println("ERROR: Type checking failed: ${typedResult.exceptionOrNull()}")
        }
        
    } finally {
        // Clean up temp directory
        tempDir.deleteRecursively()
    }
}