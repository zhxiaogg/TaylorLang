import org.taylorlang.ast.*
import org.taylorlang.typechecker.*
import org.taylorlang.codegen.*
import kotlinx.collections.immutable.persistentListOf
import java.io.File
import java.nio.file.Files

fun main() {
    println("=== While Loop Debug Trace ===")
    
    // Create simple while(false) { println("loop") }; println("done") test
    val whileLoop = WhileExpression(
        condition = Literal.BooleanLiteral(false),
        body = FunctionCall(
            target = Identifier("println"),
            arguments = persistentListOf(Literal.StringLiteral("loop"))
        )
    )
    val statements = persistentListOf(
        whileLoop,
        FunctionCall(
            target = Identifier("println"), 
            arguments = persistentListOf(Literal.StringLiteral("done"))
        )
    )
    val program = Program(statements)
    
    // Type check
    val typeChecker = RefactoredTypeChecker()
    val typedProgramResult = typeChecker.typeCheck(program)
    
    when {
        typedProgramResult.isSuccess -> {
            val typedProgram = typedProgramResult.getOrThrow()
            println("✓ Type checking passed")
            
            // Generate bytecode
            val generator = BytecodeGenerator()
            val tempDir = Files.createTempDirectory("taylor_debug_while").toFile()
            val codegenResult = generator.generateBytecode(typedProgram, tempDir, "WhileDebug")
            
            when {
                codegenResult.isSuccess -> {
                    val generationResult = codegenResult.getOrThrow()
                    println("✓ Bytecode generation passed")
                    println("Generated files: ${generationResult.bytecodeFiles.map { it.name }}")
                    
                    // Try to run the generated bytecode
                    try {
                        val process = ProcessBuilder("java", "-cp", tempDir.absolutePath, "WhileDebug")
                            .redirectOutput(ProcessBuilder.Redirect.PIPE)
                            .redirectError(ProcessBuilder.Redirect.PIPE)
                            .start()
                        
                        val output = process.inputStream.bufferedReader().readText()
                        val error = process.errorStream.bufferedReader().readText()
                        val exitCode = process.waitFor()
                        
                        println("Exit code: $exitCode")
                        println("Output: '$output'")
                        if (error.isNotEmpty()) {
                            println("Error: '$error'")
                        }
                        
                        // Expected: "done\n", Actual: ?
                        println("Expected: 'done\\n'")
                        println("Actual length: ${output.length}")
                        println("Actual bytes: ${output.toByteArray().toList()}")
                    } catch (e: Exception) {
                        println("Execution failed: $e")
                    }
                } else {
                    println("✗ Bytecode generation failed: ${codegenResult.exceptionOrNull()}")
                }
            }
        } else {
            println("✗ Type checking failed: ${typedProgramResult.exceptionOrNull()}")
        }
    }
}
EOF < /dev/null